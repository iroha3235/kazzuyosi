import React, { useRef, useEffect, useState } from 'react';

const ArmJointIK = () => {
  const canvasRef = useRef(null);
  const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
  const [isPressed, setIsPressed] = useState(false);
  
  // 定数
  const UPPER_ARM = 100; // 上腕の長さ（肩から肘）
  const FOREARM = 80;    // 前腕の長さ（肘から手）
  
  // 関節位置
  const shoulder = { x: 300, y: 150 }; // 肩（固定）
  const [elbow, setElbow] = useState({ x: 350, y: 250 });
  const [hand, setHand] = useState({ x: 400, y: 300 });

  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    
    const draw = () => {
      // 背景
      ctx.fillStyle = '#666';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // 線を描画
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(shoulder.x, shoulder.y);
      ctx.lineTo(elbow.x, elbow.y);
      ctx.lineTo(hand.x, hand.y);
      ctx.stroke();
      
      // 補助線（肩から手への直線）
      ctx.strokeStyle = '#888';
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.moveTo(shoulder.x, shoulder.y);
      ctx.lineTo(hand.x, hand.y);
      ctx.stroke();
      ctx.setLineDash([]);
      
      // 関節を描画
      // 肩（赤）
      ctx.fillStyle = '#f00';
      ctx.beginPath();
      ctx.arc(shoulder.x, shoulder.y, 12, 0, Math.PI * 2);
      ctx.fill();
      
      // 肘（緑）
      ctx.fillStyle = '#0f0';
      ctx.beginPath();
      ctx.arc(elbow.x, elbow.y, 12, 0, Math.PI * 2);
      ctx.fill();
      
      // 手（青）
      ctx.fillStyle = '#00f';
      ctx.beginPath();
      ctx.arc(hand.x, hand.y, 12, 0, Math.PI * 2);
      ctx.fill();
      
      // ラベル
      ctx.fillStyle = '#fff';
      ctx.font = '14px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('肩:a', shoulder.x, shoulder.y - 20);
      ctx.fillText('肘:b', elbow.x, elbow.y - 20);
      ctx.fillText('手:c', hand.x, hand.y - 20);
      
      // 長さ表示
      ctx.fillStyle = '#ff0';
      ctx.font = '12px sans-serif';
      const midUpper = {
        x: (shoulder.x + elbow.x) / 2,
        y: (shoulder.y + elbow.y) / 2
      };
      const midFore = {
        x: (elbow.x + hand.x) / 2,
        y: (elbow.y + hand.y) / 2
      };
      ctx.fillText(`上腕:${UPPER_ARM}`, midUpper.x, midUpper.y - 10);
      ctx.fillText(`前腕:${FOREARM}`, midFore.x, midFore.y - 10);
      
      // 距離情報
      const dist = Math.sqrt((hand.x - shoulder.x) ** 2 + (hand.y - shoulder.y) ** 2);
      const maxReach = UPPER_ARM + FOREARM;
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'left';
      ctx.fillText(`肩から手までの距離: ${dist.toFixed(1)}`, 10, 20);
      ctx.fillText(`最大到達距離: ${maxReach}`, 10, 40);
      ctx.fillText(dist > maxReach ? '⚠ 届かない範囲です' : '✓ 到達可能', 10, 60);
    };
    
    draw();
  }, [elbow, hand]);

  const updateArmPosition = (targetX, targetY) => {
    // 肩から目標位置への距離
    const dx = targetX - shoulder.x;
    const dy = targetY - shoulder.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    // 最大到達距離
    const maxReach = UPPER_ARM + FOREARM;
    
    let finalHandX = targetX;
    let finalHandY = targetY;
    
    // 届かない場合は最大距離の位置に制限
    if (distance > maxReach) {
      const angle = Math.atan2(dy, dx);
      finalHandX = shoulder.x + Math.cos(angle) * maxReach;
      finalHandY = shoulder.y + Math.sin(angle) * maxReach;
    }
    
    // 新しい手の位置からIKで肘の位置を計算
    const newDx = finalHandX - shoulder.x;
    const newDy = finalHandY - shoulder.y;
    const newDist = Math.sqrt(newDx * newDx + newDy * newDy);
    
    // 余弦定理で肘の角度を求める
    // a² = b² + c² - 2bc*cosA
    const cosAngle = (UPPER_ARM * UPPER_ARM + newDist * newDist - FOREARM * FOREARM) 
                     / (2 * UPPER_ARM * newDist);
    
    // 計算可能な範囲かチェック
    if (cosAngle >= -1 && cosAngle <= 1) {
      const angle1 = Math.acos(cosAngle);
      const baseAngle = Math.atan2(newDy, newDx);
      
      // 肘の角度（下向きに曲げる）
      const elbowAngle = baseAngle + angle1;
      
      const newElbowX = shoulder.x + Math.cos(elbowAngle) * UPPER_ARM;
      const newElbowY = shoulder.y + Math.sin(elbowAngle) * UPPER_ARM;
      
      setElbow({ x: newElbowX, y: newElbowY });
    }
    
    setHand({ x: finalHandX, y: finalHandY });
  };

  const handleMouseMove = (e) => {
    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    setMousePos({ x, y });
    
    if (isPressed) {
      updateArmPosition(x, y);
    }
  };

  const handleMouseDown = (e) => {
    setIsPressed(true);
    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    updateArmPosition(x, y);
  };

  const handleMouseUp = () => {
    setIsPressed(false);
  };

  return (
    <div className="flex flex-col items-center justify-center min-h-screen bg-gray-800 p-4">
      <div className="bg-white p-6 rounded-lg shadow-lg mb-4">
        <h1 className="text-2xl font-bold mb-2">2関節アームの逆運動学（IK）</h1>
        <p className="text-gray-600 mb-4">
          マウスをドラッグして手の位置を動かしてください
        </p>
        <div className="bg-blue-50 border border-blue-200 rounded p-3 mb-4">
          <p className="text-sm"><strong>仕組み：</strong></p>
          <ol className="text-sm list-decimal list-inside space-y-1 mt-2">
            <li>マウス位置を目標の手の位置とする</li>
            <li>肩から手までの距離が最大到達距離を超えないか確認</li>
            <li>余弦定理を使って肘の角度を計算</li>
            <li>計算した角度から肘の座標を求める</li>
          </ol>
        </div>
      </div>
      
      <canvas
        ref={canvasRef}
        width={600}
        height={400}
        className="border-4 border-white rounded cursor-crosshair"
        onMouseMove={handleMouseMove}
        onMouseDown={handleMouseDown}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseUp}
      />
      
      <div className="mt-4 text-white text-sm">
        <p>上腕の長さ: {UPPER_ARM}px | 前腕の長さ: {FOREARM}px</p>
      </div>
    </div>
  );
};

export default ArmJointIK;
